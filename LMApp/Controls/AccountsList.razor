@using LMApp.Models.Account
@using LMApp.Models.Categories
@using LMApp.Models.Context
@using LMApp.Models.UI
@using System.Text
@using Microsoft.AspNetCore.Components
@inject FormatService formatService
@inject Utils utils
@inject SettingsService settingsService
@inject BudgetService budgetService
@inject NavigationManager navigationManager

<div @ref="containerRef" @onkeydown="HandleKeyDown" @onkeydown:preventDefault="preventKeyDownDefault" tabindex="0">
    @if (!IsAccountEditMode)
    {
        @* Normal display mode *@
        @foreach (var item in Accounts.Select((account, index) => (account: account, index: index)))
        {
            <div class="@GetRowClass(item.account, item.index)" data-index="@item.index">
                <a href="javascript:" class="account-row-inner" @onclick="() => OnClick(item.account)" role="button">
                    <div class="container p-0">
                        <div class="row g-0">
                            <div class="col-7 mb-2">
                                <h5>
                                    @item.account.Name
                                </h5>
                            </div>
                            <div class="col-5 text-end balance text-secondary">@formatService.FormatBalance(item.account.Balance, item.account.Currency, item.account.IsLiability)</div>
                            @if (item.account.LiabilitiesBalance.HasValue)
                            {
                                <div class="col-6 text-secondary total-box"><span class="total-sub-label">Liabilities:</span> @formatService.FormatBalance(item.account.LiabilitiesBalance.Value, item.account.Currency, true)</div>
                            }
                            @if (item.account.AssetsBalance.HasValue)
                            {
                                <div class="col-6 text-secondary text-end total-box"><span class="total-sub-label">Assets:</span> @formatService.FormatBalance(item.account.AssetsBalance.Value, item.account.Currency, false)</div>
                            }
                        </div>
                    </div>
                </a>
            </div>
        }
    }
    else
    {
        @* Account edit mode - use the new components *@
        @foreach (var item in Accounts.Where(a => a.AccountType != AccountType.Total).Select((account, index) => (account: account, index: index)))
        {            <AccountItemEditor Account="@item.account"
                               EditingAccount="@EditingAccount"
                               IsEditing="@(EditingAccountId == item.account.IdForType)"
                               AccountTypes="@AccountTypes"
                               CurrencyItems="@CurrencyItems"
                               OnEdit="() => StartEditAccount(item.account)"
                               OnCancel="CancelAccountEdit"
                               OnSave="SaveAccountEdit"
                               OnDelete="ShowDeleteAccountModal"
                               IsEditDisabled="@HasUnsavedChanges"
                               IsSaving="@IsSaving"
                               SaveErrorMessage="@AccountSaveErrorMessage" />
        }

        @* Add new account section *@
        @if (IsAddingNewAccount)
        {
            <NewAccountForm NewAccount="@NewAccount"
                            AccountTypes="@AccountTypes"
                            CurrencyItems="@CurrencyItems"
                            OnCancel="CancelNewAccount"
                            OnSave="SaveNewAccount"
                            IsSaving="@IsSaving"
                            SaveErrorMessage="@AccountSaveErrorMessage" />
        }
        else 
        {
            @* Show add new account button only when not editing any account *@
            <div class="text-center mb-3">
                <Button class="me-2"
                        Icon="fa-solid fa-plus"
                        Color="Color.Primary"
                        Size="Size.Large"
                        IsOutline="true"
                        Text="Add New Account"
                        OnClick="StartAddNewAccount"
                        IsDisabled="HasUnsavedChanges || IsSaving" />
            </div>
        }
    }

    @* Bottom panel *@
    <div class="p-4 d-flex justify-content-center gap-2">
        @if (IsSaving)
        {
            <div class="d-flex align-items-center">
                <Spinner />
                <span class="ms-2">Saving...</span>
            </div>
        }
        else if (!IsAccountEditMode)
        {
            <Button Color="Color.Secondary" IsOutline="true" Text="Edit Accounts" OnClick="EnterAccountEditMode" />
        }
        else
        {
            <Button Color="Color.Secondary" IsOutline="true" Text="Exit account edit" OnClick="ExitAccountEditMode" />
        }
    </div>
</div>

@code {
    private ElementReference containerRef;
    private int selectedIndex = -1;
    private bool preventKeyDownDefault;

    [Inject]
    public ILogger<AccountsList> log { get; set; }

    // Account edit mode properties
    private bool IsAccountEditMode = false;
    private bool IsSaving = false;
    private string AccountSaveErrorMessage = null;

    // Individual account editing
    private long? EditingAccountId = null;
    private AccountDisplayForEdit EditingAccount = null;
    private EditContext EditContext;

    // New account creation
    private bool IsAddingNewAccount = false;
    private AccountDisplayForEdit NewAccount = null;

    private IEnumerable<SelectedItem> CurrencyItems;
    private IEnumerable<SelectedItem> AccountTypes;

    private string GetRowClass(AccountDisplay account, int index)
    {
        var sb = new StringBuilder("account-row ");
        sb.Append(account.AccountType.ToString().ToLower());
        if (ActiveAccountUid == account.Uid)
        {
            sb.Append(" active");
        }
        if (selectedIndex == index)
        {
            sb.Append(" keyboard-selected");
        }
        return sb.ToString();
    }

    private bool HasAccountChanges => EditingAccount?.HasChanges() ?? false;
    private bool HasNewAccountChanges => NewAccount?.HasChanges() ?? false;
    private bool HasUnsavedChanges => HasAccountChanges || HasNewAccountChanges;
    private bool AllowStartEdit => !HasUnsavedChanges && !IsSaving;

    [Parameter]
    public AccountDisplay[] Accounts { get; set; }

    [Parameter]
    public EventCallback OnNavigateRight { get; set; }

    [Parameter]
    public EventCallback AccountsChanged { get; set; }

    [CascadingParameter] 
    public IModalContainer ModalContainer { get; set; }

    [Parameter]
    public string ActiveAccountUid { get; set; }

    [Parameter]
    public EventCallback<AccountDisplay> AccountSelected { get; set; }

    [Parameter]
    public EventCallback StartAccountsEdit { get; set; }

    private Task OnClick(AccountDisplay account)
    {
        return AccountSelected.InvokeAsync(account);
    }

    private async Task EnterAccountEditMode()
    {
        await StartAccountsEdit.InvokeAsync();
        IsAccountEditMode = true;
        StateHasChanged();
    }

    private void ExitAccountEditMode()
    {
        CancelAccountEdit();
        CancelNewAccount();
        IsAccountEditMode = false;
        StateHasChanged();
    }

    private void StartEditAccount(AccountDisplay account)
    {
        if (HasUnsavedChanges 
            || account.AccountType != AccountType.Default
            || EditingAccountId == account.IdForType)
            return;

        CancelNewAccount();

        EditingAccountId = account.IdForType;
        EditingAccount = AccountDisplayForEdit.FromAccountDisplay(account);
        EditContext = new EditContext(EditingAccount);
        StateHasChanged();
    }

    private async Task ShowDeleteAccountModal(AccountDisplayForEdit account)
    {
        await ModalContainer.Modal.Show(new InfoModalVM
        {
            Title = "Delete Account",
            Message = new MarkupString($"<p>Account deletion is not available in BBudget.</p><p>To delete the account <strong>\"{account.Name}\"</strong>, please use the Lunch Money. Please reload BBudget if you have deleted account.</p>"),
            ModalSize = Size.Medium,
            AdditionalButtonText = "Open Lunch Money",
            AdditionalButtonColor = Color.Primary,
            AdditionalButtonCallback = () => OpenLunchMoneyAccounts(),
            AdditionalButton2Color = Color.Warning,
            AdditionalButton2Text = "Reload BBudget",
            AdditionalButton2Callback = () => ReloadBBudget()
        });
    }

    private async Task OpenLunchMoneyAccounts()
    {
        await utils.OpenNewTab("https://my.lunchmoney.app/accounts");
    }

    private Task ReloadBBudget()
    {
        navigationManager.NavigateTo(navigationManager.Uri, forceLoad: true);
        return Task.CompletedTask;
    }

    private void CancelAccountEdit()
    {
        IsSaving = false;
        AccountSaveErrorMessage = null;
        EditingAccountId = null;
        EditingAccount = null;
        EditContext = null;
        StateHasChanged();
    }

    private async Task SaveAccountEdit()
    {
        EditingAccount?.TrimAll();

        if (EditingAccount == null || !EditContext.Validate())
            return;

        IsSaving = true;
        StateHasChanged();

        try
        {
            var accountsToSave = new List<AccountDisplayForEdit> { EditingAccount };
            var madeChanges = await budgetService.SaveEditedAccountsAsync(accountsToSave);
            if (madeChanges)
            {
                await AccountsChanged.InvokeAsync();
            }
            IsSaving = false;
            CancelAccountEdit();
        }
        catch (HttpRequestException ex)
        {
            ex.LogIfRequired(log);
            AccountSaveErrorMessage = ex.GetDescriptionForUser();
        }
    }

    private void StartAddNewAccount()
    {
        if (HasUnsavedChanges)
            return;

        CancelAccountEdit();

        NewAccount = AccountDisplayForEdit.CreateNewAccount(settingsService.PrimaryCurrency);
        EditContext = new EditContext(NewAccount);
        IsAddingNewAccount = true;
    }

    private void CancelNewAccount()
    {
        IsSaving = false;
        AccountSaveErrorMessage = null;
        IsAddingNewAccount = false;
        NewAccount = null;
        EditContext = null;
    }

    private async Task SaveNewAccount()
    {
        NewAccount?.TrimAll();

        if (NewAccount == null || !EditContext.Validate())
            return;

        AccountSaveErrorMessage = null;
        IsSaving = true;
        StateHasChanged();

        try
        {
            var accountsToSave = new List<AccountDisplayForEdit> { NewAccount };
            var madeChanges = await budgetService.SaveEditedAccountsAsync(accountsToSave);

            if (madeChanges)
            {
                await AccountsChanged.InvokeAsync();
            }
            CancelNewAccount();
            IsSaving = false;
        }
        catch (HttpRequestException ex)
        {
            ex.LogIfRequired(log);
            AccountSaveErrorMessage = ex.GetDescriptionForUser();
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (IsAccountEditMode) return; // Disable keyboard navigation in edit mode

        preventKeyDownDefault = false;
        if (Accounts == null || Accounts.Length == 0)
            return;

        switch (e.Key)
        {
            case "ArrowDown":
                if (selectedIndex < Accounts.Length - 1)
                {
                    preventKeyDownDefault = true;
                    selectedIndex++;
                    StateHasChanged();
                    await ScrollToSelectedItem();
                }
                break;
            case "ArrowUp":
                if (selectedIndex > 0)
                {
                    preventKeyDownDefault = true;
                    selectedIndex--;
                    StateHasChanged();
                    await ScrollToSelectedItem();
                }
                else if (selectedIndex == -1 && Accounts.Length > 0)
                {
                    preventKeyDownDefault = true;
                    selectedIndex = 0;
                    StateHasChanged();
                    await ScrollToSelectedItem();
                }
                break;
            case "ArrowRight":
                await OnNavigateRight.InvokeAsync();
                break;
            case "Enter":
                if (selectedIndex >= 0 && selectedIndex < Accounts.Length)
                {
                    preventKeyDownDefault = true;
                    await OnClick(Accounts[selectedIndex]);
                }
                break;
        }
    }

    protected override void OnParametersSet()
    {
        // Find the index of the active account
        if (!string.IsNullOrEmpty(ActiveAccountUid) && Accounts != null && selectedIndex < 0)
        {
            var activeIndex = Array.FindIndex(Accounts, a => a.Uid == ActiveAccountUid);
            if (activeIndex >= 0)
            {
                selectedIndex = activeIndex;
            }
        }
    }

    protected override void OnInitialized()
    {
        // Initialize currency dropdown items
        CurrencyItems = settingsService.SelectedAccountCurrencies
            .Select(x => new SelectedItem
            {
                Text = formatService.CurrencyToSymbol(x),
                Value = x
            });

        AccountTypes = Enum.GetValues<LMAccountType>()
            .Select(at => new SelectedItem
            {
                Text = formatService.LMAccountTypeName(at),
                Value = at.ToString()
            }).OrderBy(x=>x.Text).ToArray();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await TryFocus();
        }
    }

    private async Task ScrollToSelectedItem()
    {
        await Task.Yield(); // Ensure UI updates before scrolling
        await utils.ScrollToSelectedItem(containerRef, "keyboard-selected");
    }

    public Task FocusAsync()
    {
        return TryFocus();
    }

    private async Task TryFocus()
    {
        if (containerRef.Context != null && containerRef.Id != null)
        {
            try
            {
                await containerRef.FocusAsync();
            }
            catch
            {
                //ignore error
            }
        }
    }
}
